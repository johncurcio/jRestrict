Event doorClosed = new Event("doorClosed", "D1CL");
Event drawerOpened = new Event("drawerOpened", "D2OP");
Event lightOn = new Event("lightOn", "L1ON");
Event doorOpened = new Event("doorOpened", "D1OP");
Event panelClosed = new Event("panelClosed", "PNCL");
Command unlockPanelCmd = new Command("unlockPanel", "PNUL");
Command lockPanelCmd = new Command("lockPanel", "PNLK");
Command lockDoorCmd = new Command("lockDoor", "D1LK");
Command unlockDoorCmd = new Command("unlockDoor", "D1UL");
State idle = new State("idle");
State activeState = new State("active");
State waitingForLightState = new State("waitingForLight");
State waitingForDrawerState = new State("waitingForDrawer");
State unlockedPanelState = new State("unlockedPanel");
StateMachine machine = new StateMachine(idle);
idle.addTransition(doorClosed, activeState);
idle.addAction(unlockDoorCmd);
idle.addAction(lockPanelCmd);
activeState.addTransition(drawerOpened, waitingForLightState);
activeState.addTransition(lightOn, waitingForDrawerState);
waitingForLightState.addTransition(lightOn, unlockedPanelState);
waitingForDrawerState.addTransition(drawerOpened, unlockedPanelState);
unlockedPanelState.addAction(unlockPanelCmd);
unlockedPanelState.addAction(lockDoorCmd);
unlockedPanelState.addTransition(panelClosed, idle);
machine.addResetEvents(doorOpened);
Controller controller = new Controller(machine);
controller.handle("D1CL");
controller.handle("D2OP");
//controller.handle("D1OP");
controller.handle("L1ON");
controller.handle("PNCL");

StateMachineLexer sml = new StateMachineLexer("events -- comentário\neventsABC D1CL => end action {} XYZ XYZABC");
return new Token[] { sml.proximoToken(), sml.proximoToken(), sml.proximoToken(), sml.proximoToken(),
		sml.proximoToken(), sml.proximoToken(), sml.proximoToken(), sml.proximoToken(),
		sml.proximoToken(), sml.proximoToken(), sml.proximoToken(), sml.proximoToken() };


[<1,events,0>, <5,eventsABC,21>, <6,D1CL,31>, <7,=>,36>, <2,end,39>, <4,action,43>, <123,{,50>, <125,},51>, <8,XYZ,53>, <6,XYZA,57>,
<8,BC,61>, <0,<<EOF>>,63>]

String entrada = 
"events abcXYZ D1CL fooBar XYZ end comands comandoABC ABCD cmdAbre ABR1 state idle idle => idle end lixo";		
StateMachineParser smp = new StateMachineParser(entrada);
smp.parse();
return smp.erros;

[código mal-formado na posição 26, 
 encontrado nome na posição 34, mas esperado commands, 
 encontrado state na posição 71, mas esperado end, 
 encontrado nome na posição 99, mas esperado state, 
 encontrado EOF na posição 103, mas esperado end]

String entrada =
"20+foo*302/bar-(20+xyz))";
ExpParser ep = new ExpParser(entrada);
ep.parse();
return ep.erros;
		 
[encontrado nome na posição 3, mas esperado +, -, *, /, 
 encontrado + na posição 17, mas esperado (, num, nome]

cp.StateMachineLexer sml = new cp.StateMachineLexer(
		"events abcXYZ D1CL fooBar XYZZ end commands comandoABC ABCD cmdAbre ABR1 end state idle idle => idle end lixo"		
);
java.util.List<cp.Token> ent = new java.util.ArrayList<>();
cp.Token tok = sml.proximoToken();
do {
	ent.add(tok);
	tok = sml.proximoToken();
} while(tok.tipo != 0);
cp.Parser event = cpl.seq(cpl.token(5), cpl.token(6));
cp.Parser command = cpl.seq(cpl.token(5), cpl.token(6));
cp.Parser events = cpl.seq(cpl.token(1), cpl.plus(event), cpl.token(2));
cp.Parser commands = cpl.seq(cpl.token(10), cpl.plus(command), cpl.token(2));
cp.Parser revents = cpl.seq(cpl.token(9), cpl.plus(cpl.token(5)), cpl.token(2));
cp.Parser transition = cpl.seq(cpl.token(5), cpl.token(7), cpl.token(5));
cp.Parser actions = cpl.seq(cpl.token(4), cpl.token('{'), cpl.plus(cpl.token(5)), cpl.token('}'));
cp.Parser state = cpl.seq(cpl.token(3), cpl.token(5), cpl.opt(actions), cpl.star(transition), cpl.token(2));
cp.Parser machine = cpl.seq(events, cpl.opt(revents), commands, cpl.plus(state));
return machine.parse(ent);

cp.StateMachineLexer sml = new cp.StateMachineLexer(
		"abcXYZ D1CL fooBar XYZZ comandoABC ABCD cmdAbre ABR1"
);
java.util.List<cp.Token> ent = new java.util.ArrayList<>();
cp.Token tok;
do {
	tok = sml.proximoToken();
	ent.add(tok);
} while(tok.tipo != 0);
cp.Parser event = cpl.seq(cpl.token(5), cpl.token(6));
cp.Parser events = cpl.star(event);
return events.parse(ent);
return cpl.seq(event, events).parse(ent);

[
 [<0,<<EOF>>,52>], 
 [<5,cmdAbre,40>, <6,ABR1,48>, <0,<<EOF>>,52>], 
 [<5,comandoABC,24>, <6,ABCD,35>, <5,cmdAbre,40>, <6,ABR1,48>, <0,<<EOF>>,52>], 
 [<5,fooBar,12>, <6,XYZZ,19>, <5,comandoABC,24>, <6,ABCD,35>, <5,cmdAbre,40>, <6,ABR1,48>, <0,<<EOF>>,52>]
]

[
 [<0,<<EOF>>,52>], 
 [<5,cmdAbre,40>, <6,ABR1,48>, <0,<<EOF>>,52>], 
 [<5,comandoABC,24>, <6,ABCD,35>, <5,cmdAbre,40>, <6,ABR1,48>, <0,<<EOF>>,52>],
 [<5,fooBar,12>, <6,XYZZ,19>, <5,comandoABC,24>, <6,ABCD,35>, <5,cmdAbre,40>, <6,ABR1,48>, <0,<<EOF>>,52>], 
 [<5,abcXYZ,0>, <6,D1CL,7>, <5,fooBar,12>, <6,XYZZ,19>, <5,comandoABC,24>, <6,ABCD,35>, <5,cmdAbre,40>, <6,ABR1,48>, <0,<<EOF>>,52>]
]

/*
 exp := termo (‘+’ termo | ‘-’ termo)*
 termo := fator (‘*’ fator | ‘/’ fator)*
 fator := ‘(‘ exp ‘)’ | NUM | NAME
*/
java.util.Map<String,cp.Parser> g = new java.util.HashMap<>();
g.put("exp", cpl.seq(cpl.var(g, "termo"), cpl.star(cpl.choice(cpl.seq(cpl.token('+'), cpl.var(g, "termo")), cpl.seq(cpl.token('-'), cpl.var(g, "termo"))))));		
g.put("termo", cpl.seq(cpl.var(g, "fator"), cpl.star(cpl.choice(cpl.seq(cpl.token('*'), cpl.var(g, "fator")), cpl.seq(cpl.token('/'), cpl.var(g, "fator"))))));		
g.put("fator", cpl.choice(cpl.seq(cpl.token('('), cpl.var(g, "exp"), cpl.token(')')), cpl.token(2), cpl.token(1)));
String entrada =
"20+foo*302/bar-(20+xyz))";
java.util.List<cp.Token> ent = new java.util.ArrayList<>();
cp.ExpLexer el = new cp.ExpLexer(entrada);
cp.Token tok;
do {
	tok = el.proximoToken();
	ent.add(tok);
} while(tok.tipo != 0);
return cpl.var(g, "exp").parse(ent);


dcp.StateMachineLexer sml = new dcp.StateMachineLexer(
		"abcXYZ D1CL fooBar XYZZ comandoABC ABCD cmdAbre ABR1"
);
java.util.List<dcp.Token> ent = new java.util.ArrayList<>();
dcp.Token tok;
do {
	tok = sml.proximoToken();
	ent.add(tok);
} while(tok.tipo != 0);
dcp.Parser event = dcpl.seq(dcpl.token(5), dcpl.token(6));
dcp.Parser events = dcpl.star(event);
return dcpl.seq(events, dcpl.token(0)).parse(ent);

String entradaErr = 
"events abcXYZ D1CL fooBar end comands comandoABC ABCD cmdAbre ABR1 state idle idle => idle end stat foo foo => idle end lixo";		
String entradaCorr =
"events abcXYZ D1CL fooBar XYZZ end commands comandoABC ABCD cmdAbre ABR1 end state idle idle => idle end";
dcp.StateMachineLexer sml = new dcp.StateMachineLexer(entradaErr);
java.util.List<dcp.Token> ent = new java.util.ArrayList<>();
dcp.Token tok;
do {
	tok = sml.proximoToken();
	ent.add(tok);
} while(tok.tipo != 0);
dcp.Parser event = dcpl.seq(dcpl.token(5), dcpl.token(6, 8));
dcp.Parser command = dcpl.seq(dcpl.token(5), dcpl.token(6, 8));
dcp.Parser events = dcpl.seq(dcpl.token(1, "ev"), dcpl.plus(event), dcpl.token(2));
dcp.Parser commands = dcpl.seq(dcpl.token(10, "com"), dcpl.plus(command), dcpl.token(2));
dcp.Parser revents = dcpl.seq(dcpl.token(9, "reset"), dcpl.plus(dcpl.token(5)), dcpl.token(2));
dcp.Parser transition = dcpl.seq(dcpl.token(5), dcpl.token(7), dcpl.token(5));
dcp.Parser actions = dcpl.seq(dcpl.token(4, "act"), dcpl.token('{'), dcpl.plus(dcpl.token(5)), dcpl.token('}'));
dcp.Parser state = dcpl.seq(dcpl.token(3, "sta"), dcpl.token(5), dcpl.opt(actions), dcpl.star(transition), dcpl.token(2));
dcp.Parser machine = dcpl.seq(events, dcpl.opt(revents), commands, dcpl.plus(state));
peg.Pair<mast.Machine, java.util.List<String>> res = dcp.dcpl.run(sml, machine, ent);
mast.CollectVisitor cv = new mast.CollectVisitor(res.y);
mast.BindingVisitor bv = new mast.BindingVisitor(res.y);
res.x.visit(cv, null);
res.x.visit(bv, null);
return res;


[erro de sintaxe na posição 4 com o token end, era esperado codigo, 
 erro de sintaxe na posição 5 com o token comands, era esperado resetEvents, commands, 
 erro de sintaxe na posição 10 com o token state, era esperado end, nome, 
 erro de sintaxe na posição 16 com o token stat, era esperado state, 
 erro de sintaxe na posição 22 com o token lixo, era esperado state, 
 erro de sintaxe na posição 23 com o token <<EOF>>, era esperado end, action, nome]

[erro de sintaxe na posição 4 com o token end, era esperado codigo, 
 erro de sintaxe na posição 5 com o token comands, era esperado resetEvents, commands, 
 erro de sintaxe na posição 10 com o token state, era esperado end, nome, 
 erro de sintaxe na posição 16 com o token stat, era esperado state, 
 erro de sintaxe na posição 22 com o token lixo, era esperado state, 
 erro de sintaxe na posição 23 com o token <<EOF>>, era esperado end, action, nome]
		 
return ExpTest.test();

return BlocoTest.test();

return BlocoTest.exec(true);
return BlocoTest.exec(false);

An exception occurred during evaluation:  java.lang.RuntimeException
An exception occurred during evaluation:  java.lang.RuntimeException

An exception occurred during evaluation:  java.lang.RuntimeException
[erro de sintaxe na posição 5 com o token 1, era esperado =, 
 erro de sintaxe na posição 17 com o token while, era esperado *, +, ;, -, >, /, 
 erro de sintaxe na posição 21 com o token f, era esperado do, *, +, -, /, 
 erro de sintaxe na posição 28 com o token x, era esperado =]

[erro de sintaxe na posição 5 com o token 1, era esperado =, 
 erro de sintaxe na posição 17 com o token while, era esperado *, +, ;, -, >, /, 
 erro de sintaxe na posição 21 com o token f, era esperado do, *, +, -, /, 
 erro de sintaxe na posição 24 com o token n, era esperado *, +, ;, -, >, /, 
 erro de sintaxe na posição 25 com o token ;, era esperado =, 
 erro de sintaxe na posição 25 com o token ;, era esperado nome, num, (, =]

		 
String entradaErr = 
 "events abcXYZ D1CL fooBar end comands comandoABC ABCD cmdAbre ABR1 state idle idle => idle end stat foo foo => idle end lixo";		
String entradaCorr =
"events abcXYZ D1CL fooBar XYZZ end commands comandoABC ABCD cmdAbre ABR1 end state idle actions { comandoABC cmdAre } idle => idle end";
peg.Pair<mast.Machine, java.util.List<String>> res = peg.peg.run(StateMachineParser.machine, entradaCorr); 
mast.CollectVisitor cv = new mast.CollectVisitor(res.y);
mast.BindingVisitor bv = new mast.BindingVisitor(res.y);
res.x.visit(cv, null);
res.x.visit(bv, null);
return res;

[erro de sintaxe na posição 26, era esperado codigo, 
 erro de sintaxe na posição 30, era esperado resetEvents, commands, 
 erro de sintaxe na posição 67, era esperado nome, end, 
 erro de sintaxe na posição 95, era esperado state, 
 erro de sintaxe na posição 120, era esperado state, 
 erro de sintaxe na posição 124, era esperado nome, end, actions]
		 
		 
interface Foo {
   void foo();
}
		 
interface Bar {
   void foo();
   void bar();
}

struct A {
  int x;
  double y;
}

struct B {
  int y;
  double x;
  char c;
}

interface X {
	Y foo();
}

interface Y {
	X foo();
}



Biblioteca a:
	
facaAlgo(Foo f) { f.foo(); }

Biblioteca b:
	
class Baz implements Bar {
	void foo() {
		...
	}
}

facaAlgo(new Baz()); // erro!

StateMachineDriver.main(new String[] { "machine.stm" });
return StateMachineDriver.machine("machine.stm");
return StateMachineDriver.read("machine.stm");
